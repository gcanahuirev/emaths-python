# DEPENDENCIES 
import math #Math functionality
import numpy #Numpy for working with arrays
import plotly as py
import plotly.graph_objs as go #Import graph objects
import shear_force_diagram

# NOT EDIT
pointLoads = numpy.array([[]])

# ANALYSIS PARAMETERS
span = 17 #Span of beam
A = 3  #Distance to left support
B = 13 #Distance to right support

# FORCE DATA
pointLoads = numpy.array([[6,0,-90]])
# Point moment location and magnitud
# pointMoments = numpy.array([17,50])
# Linear load initial location, end location, initial magnitud, end magnitud
# linearLoads = numpy.array([8,17,-10,0])
divs = 10000 # Divide span up into this number of data points
delta = span/divs # Distance between data points
X = numpy.arange(0, span+delta, delta) # Range of X-coordinates
nPL = len(pointLoads[0]) # Test for point loads to consider

#INITIALISE DATA CONTAINERS
reactions = numpy.array([0.0,0,0]) #Reactions (Va, Ha, Vb) - Defined as array of floats to hold reactions
shearForce = numpy.empty([0,len(X)]) #Shear forces at each data point
bendingMoment = numpy.empty([0, len(X)]) #Bending moment at each data point

# REACTION CALCULATION
def reactions_PL(n):       
    xp = pointLoads[n,0] #Location of point load
    fx = pointLoads[n,1] #Point load horizontal component magnitude 
    fy = pointLoads[n,2] #Point load vertical component magnitude 
    
    la_p = A-xp  #Lever arm of point load about point A
    mp = fy*la_p #Moment generated by point load about A - closkwise moments are positive
    la_vb = B-A  #Lever arm of vertical reaction at B about point A
 
    Vb = mp/la_vb #Vertical reaction at B
    Va = -fy-Vb   #Vertical reaction at A
    Ha = -fx      #Horizontal reaction at A
    
    return Va, Vb, Ha    

PL_record = numpy.empty([0,3])
 
for n, p in enumerate(pointLoads):    
    va, vb, ha = reactions_PL(n) #Calculate reactions
    PL_record = numpy.append(PL_record, [numpy.array([va, ha, vb])], axis=0) #Store reactions for each point load
 
    #Add reactions to record (superposition)
    reactions[0] = reactions[0] + va 
    reactions[1] = reactions[1] + ha
    reactions[2] = reactions[2] + vb

print(round(reactions[0], 2))
print(round(reactions[1], 2))
print(round(reactions[2], 2))

# SHEAR AND MOMENT CALCULATION
def shear_moment_PL(n):    
    xp = pointLoads[n,0] #Location of point load
    fy = pointLoads[n,2] #Point load vertical component magnitude 
    Va = PL_record[n,0]  #Vertical reaction at A for this point load
    Vb = PL_record[n,2]  #Vertical reaction at B for this point load
    
    #Cycle through the structure and calculate the shear force and bending moment at each point
    Shear = numpy.zeros(len(X))  #Initialise a container to hold all shear force data for this point load
    Moment = numpy.zeros(len(X)) #Initialise a container to hold all moment force data for this point load
    for i, x in enumerate(X):    
        shear = 0  #Initialise the shear force for this data point
        moment = 0 #Initialise the bending moment for this data point
 
        if x > A:
            #Calculate shear and moment from reaction at A
            shear = shear + Va
            moment = moment - Va*(x-A)
 
        if x > B:
            #Calculate shear and moment from reaction at B
            shear = shear + Vb
            moment = moment - Vb*(x-B)
 
        if x > xp:
            #Calculate shear and moment from point load
            shear = shear + fy
            moment = moment - fy*(x-xp)
 
        #Store shear and moment for this location
        Shear[i] = shear
        Moment[i] = moment
 
    return Shear, Moment

# Calculate the shear force and bending moment at each datapoint due to point load
for n, p in enumerate(pointLoads):
    Shear, Moment = shear_moment_PL(n)
    # Store shear force record for each point load
    shearForce = numpy.append(shearForce, [Shear], axis=0)
    # Store bending moment record for each point load
    bendingMoment = numpy.append(bendingMoment, [Moment], axis=0)

shear_force_diagram.gen(X, shearForce, span)